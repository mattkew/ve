<html>
	<head>
		<meta charset="utf-8">
		<title>vr-1</title>
		<style>
			body { margin: 0; }
		</style>
		<!--audio preload loop>
			<source src="resources/audio/vr-f-fall.mp3" type="audio/mp3">
		</audio-->
	</head>
	<body>
		<!-- <script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.js'></script>		' -->
		<script type="module">

import "./node_modules/simplex-noise/simplex-noise.js"
//import Perlin from './perlin-noise-sb.js';
import * as THREE from "./node_modules/three/build/three.module.js"
//import "../node_modules/simplex-noise/simplex-noise.js"

const COLORS = {
    LIGHT_GRAY: 0x000000, // 0xEEEEEE,
    WHITE:  0xFFFFFF
}

let width = window.innerWidth;
let height = window.innerHeight;

let scene = new THREE.Scene();

let camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 20); // 10
camera.position.y = 1.6
camera.position.z = 10 // 3
camera.rotation.x = 0

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setClearColor(COLORS.LIGHT_GRAY);
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( width, height );
renderer.shadowMap.enabled = true;
document.body.appendChild( renderer.domElement );

// VR
import { VRButton } from './js/VRButton.js';
document.body.appendChild( VRButton.createButton( renderer ) );
renderer.xr.enabled = true;
// Controllers here


// Fog
// {
//     const near = 0;
//     const far = 10;
//     const color = COLORS.LIGHT_GRAY // 'lightblue';
//     scene.fog = new THREE.Fog(color, near, far);
//     //scene.background = new THREE.Color(color);
// }

// Spotlight
const lcolor = 0xFFFFFF;
const lintensity = .5;
const light = new THREE.SpotLight(lcolor, lintensity);
light.position.set(0, 5, -0);
light.target.position.set(0, 0, -1);
light.castShadow = true;
scene.add(light);
scene.add(light.target);
//const helper = new THREE.SpotLightHelper(light);
//scene.add(helper);

// Ambient Light
const color = 0xFFFFFF;
const intensity = 0 // .0125 // .45;
const ambientlight = new THREE.AmbientLight(color, intensity);
scene.add(ambientlight);


const pGeometry = new THREE.BufferGeometry();
const vertices = [];

const textureLoader = new THREE.TextureLoader();

const sprite1 = textureLoader.load( './resources/images/flare-2.png' );

for ( let i = 0; i < 2000; i ++ ) {
    const x = Math.random() * 6 - 3;
    const y = Math.random() * 4 - 2 + 1.6;
    const z = Math.random() * -50 + 25;
    vertices.push( x, y, z );
}

pGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

//const pColor = 0xFFFFFF;
//const sprite = sprite1;
const size = 1;

const pMaterial = new THREE.PointsMaterial( { size: size, map: sprite1, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );
pMaterial.color.setHSL( 0, 0, 100 );

const particles = new THREE.Points( pGeometry, pMaterial );

scene.add(particles)



let clock = new THREE.Clock();
let movementSpeed = 3 * 4
let zIncrement = 0
let pAmp = .00125 * 4 // .1 // .00125
const simplex = new SimplexNoise(Date.now())
const scale = 2 // .125 // 50 // 1 // .125

let newZ = 0
let zPull = 0.005

function pRefreshVertices() {
	let x, y, z = 0
	
    let vertices = particles.geometry.attributes.position.array;
    for (let i = 0; i <= vertices.length; i += 3) {
        x = i
        y = i+1
        z = i+2

		// let newX = vertices[x] + simplex.noise2D(vertices[x] * scale, zIncrement * scale) * pAmp
		//console.log(vertices[x] + "-> " + simplex.noise2D(vertices[x] * scale, zIncrement * scale) * pAmp)

        vertices[x] += simplex.noise2D(vertices[x] * scale, zIncrement + vertices[y] * scale) * pAmp
       	vertices[y] += simplex.noise2D(vertices[y] * scale, zIncrement + vertices[z] * scale) * pAmp
		newZ = vertices[z] + simplex.noise2D(vertices[z] * scale, zIncrement + vertices[x] * scale) * pAmp

		newZ += zPull

		vertices[z] = newZ % 25
    }
    particles.geometry.attributes.position.needsUpdate = true;
    //particles.geometry.normalizeNormals();
    particles.geometry.computeVertexNormals();
}

function update() {
    let delta = clock.getDelta();
    
    // wall.position.z += movementSpeed * delta;
    zIncrement += .001 // movementSpeed * delta 

   pRefreshVertices()

    renderer.render( scene, camera );
}

renderer.setAnimationLoop(update)

		</script>
	</body>
</html>